'use server'

import { db } from '@/lib/db';
import { createSession, verifyPassword, hashPassword } from '@/lib/auth';
import { cookies, headers } from 'next/headers';
import { redirect } from 'next/navigation';

const COOKIE_NAME = 'auth_session';

export async function login(prevState: any, formData: FormData) {
    const username = formData.get('username') as string;
    const password = formData.get('password') as string;
    const callbackUrl = formData.get('callbackUrl') as string | null;

    if (!username || !password) return { error: '请输入用户名和密码' };

    // 1. Check for Admin Init (First Run)
    const { data: allUsers } = await db.getAllUsers(1, 100); // Check first 100 users for admin
    const hasAdmin = allUsers.some(u => u.role === 'admin');

    if (!hasAdmin) {
        // Create default admin only if no admin exists
        if (username === 'admin' && password === 'admin') {
            const hashedPassword = await hashPassword('admin');
            await db.setUser('admin', {
                id: '', // Will be generated by database
                username: 'admin',
                password: hashedPassword,
                role: 'admin',
                status: 'active',
                maxSubscriptions: null, // null = follow global settings
                createdAt: Date.now()
            });
        } else {
            return { error: '系统初始化中,请使用默认账号 admin/admin 登录' };
        }
    }

    // 2. Verify User
    const user = await db.getUser(username);
    if (!user) {
        return { error: '用户不存在' };
    }

    // Check status
    if (user.status !== 'active') {
        return { error: '账户已被停用' };
    }

    // Check password
    const isValid = await verifyPassword(password, user.password);
    if (!isValid) {
        return { error: '密码错误' };
    }

    // 2FA Verification
    if (user.totpEnabled) {
        const code = formData.get('code') as string | null;
        if (!code) {
            // Frontend should detect this error and show the code input
            return { error: '2fa_required' };
        }

        const { verify } = await import('otplib');
        let isValid2FA = false;
        try {
            // functional verify returns dictionary { valid: boolean, ... } or plain boolean?
            // Documentation says: returns VerifyResult
            // import { verify, ... } from 'otplib'; 
            // declare function verify(options: OTPVerifyOptions): Promise<VerifyResult>;
            // VerifyResult: { valid: boolean, delta?: number }
            const result = await verify({ token: code, secret: user.totpSecret || '' });
            isValid2FA = !!(result && result.valid);
        } catch (e) {
            isValid2FA = false;
        }

        if (!isValid2FA) {
            return { error: '两步验证码错误' };
        }
    }

    // 3. Create Session
    const headersList = await headers();
    const ip = headersList.get('x-forwarded-for') || headersList.get('x-real-ip') || 'unknown';
    const ua = headersList.get('user-agent') || 'unknown';

    const sessionId = await createSession(username, user.role, ip, ua, 'password'); // Pass IP and UA

    // 4. Set Cookie
    (await cookies()).set(COOKIE_NAME, sessionId, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax',
        maxAge: 7 * 24 * 60 * 60, // 7 days
    });

    // 5. Redirect to callback URL or default based on role
    if (callbackUrl && callbackUrl.startsWith('/')) {
        // Validate callback URL is internal
        redirect(callbackUrl);
    } else if (user.role === 'admin') {
        redirect('/admin');
    } else {
        redirect('/dashboard');
    }
}

export async function logout() {
    const cookieStore = await cookies();
    const sessionId = cookieStore.get(COOKIE_NAME)?.value;

    if (sessionId) {
        await db.deleteSession(sessionId);
    }

    cookieStore.delete(COOKIE_NAME);
    redirect('/login');
}

// QR Code Login Actions

export async function generateQrToken() {
    const headersList = await headers();
    const ip = headersList.get('x-forwarded-for') || headersList.get('x-real-ip') || 'unknown';
    const ua = headersList.get('user-agent') || 'unknown';

    // Generate simple token
    const token = crypto.randomUUID();
    const expiresAt = Date.now() + 1 * 60 * 1000; // 1 minute

    const payload = JSON.stringify({
        status: 'pending',
        ip,
        ua,
        expiresAt
    });

    // Lazy cleanup: Delete expired QR tokens from DB
    await db.cleanupQrCache().catch(e => console.error('QR cleanup failed:', e));

    await db.setCache(`qr:${token}`, payload, 60);
    return { token, expiresAt };
}

export async function checkQrStatus(token: string) {
    if (!token) return { status: 'error' };

    const cacheData = await db.getCache(`qr:${token}`);
    if (!cacheData) {
        return { status: 'expired' };
    }

    let data;
    try {
        data = JSON.parse(cacheData);
    } catch (e) {
        return { status: 'error' };
    }

    if (Date.now() > data.expiresAt) {
        return { status: 'expired' };
    }

    if (data.status === 'confirmed' && data.userId) {
        // Login the user
        const user = await db.getUserById(data.userId);
        if (!user) return { status: 'error', message: 'User not found' };

        const headersList = await headers();
        const ip = headersList.get('x-forwarded-for') || headersList.get('x-real-ip') || 'unknown';
        const ua = headersList.get('user-agent') || 'unknown';

        const sessionId = await createSession(user.username, user.role, ip, ua, 'qr');

        (await cookies()).set(COOKIE_NAME, sessionId, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'lax',
            maxAge: 7 * 24 * 60 * 60, // 7 days
        });

        // Clear cache
        await db.deleteCache(`qr:${token}`);

        return { status: 'success' };
    }

    return { status: data.status };
}
