'use server'

import { db } from '@/lib/db';
import { generateToken } from '@/lib/utils';
import { hashPassword } from '@/lib/auth';
import { revalidatePath } from 'next/cache';
import { SubData } from '@/lib/database/interface';

// User Management
export async function getUsers(page: number = 1, limit: number = 10, search?: string) {
    return await db.getAllUsers(page, limit, search);
}

export async function createUser(formData: FormData) {
    const username = formData.get('username') as string;
    const password = formData.get('password') as string;
    const nickname = formData.get('nickname') as string;
    const rules = formData.get('customRules') as string;
    const role = (formData.get('role') as string) || 'user';
    const status = 'active';

    if (!username || !password) return { error: 'Missing fields' };

    // Check existing
    if (await db.userExists(username)) {
        return { error: 'User already exists' };
    }

    const hashedPassword = await hashPassword(password);

    // 1. Create User
    await db.setUser(username, {
        id: '', // Will be generated by database
        username,
        password: hashedPassword,
        role,
        status,
        maxSubscriptions: null, // null = follow global settings
        nickname: nickname || undefined,
        createdAt: Date.now()
    });

    // Check subscription limit before creating default subscription
    const user = await db.getUser(username);
    const config = await db.getGlobalConfig();
    const userLimit = user?.maxSubscriptions ?? config.maxUserSubscriptions ?? 10;
    const currentSubs = await db.getUserSubscriptions(username);

    if (currentSubs.length >= userLimit) {
        // User created but can't create subscription due to limit
        return { error: `用户已创建，但无法创建订阅：已达订阅上限 (${userLimit})` };
    }

    // Get default or first upstream source
    const upstreamSources = await db.getUpstreamSources();
    let selectedSources: string[] = [];

    if (upstreamSources.length > 0) {
        // Find default source
        const defaultSource = upstreamSources.find(s => s.isDefault);
        if (defaultSource) {
            selectedSources = [defaultSource.name];
        } else {
            // Use first source if no default
            selectedSources = [upstreamSources[0].name];
        }
    }

    // 2. Create Default Subscription
    const token = generateToken();
    const subData: SubData = {
        username,
        remark: '默认订阅',
        customRules: rules || '',
        groupId: 'default',
        ruleId: 'default',
        selectedSources, // Only default or first source
        enabled: true,
        createdAt: Date.now()
    };
    await db.createSubscription(token, username, subData);

    revalidatePath('/admin');
    return { success: true };
}

export async function updateUserStatus(username: string, status: string) {
    const user = await db.getUser(username);
    if (user) {
        user.status = status;
        await db.setUser(username, user);
        revalidatePath('/admin');
    }
}

export async function updateUserMaxSubscriptions(username: string, maxSubscriptions: number | null) {
    const user = await db.getUser(username);
    if (user) {
        user.maxSubscriptions = maxSubscriptions;
        await db.setUser(username, user);
        revalidatePath('/admin');
    }
}

export async function updateUser(oldUsername: string, newUsername: string, newPassword?: string, nickname?: string) {
    // Get existing user data
    const user = await db.getUser(oldUsername);
    if (!user) return { error: 'User not found' };

    // If username changed, check if new username exists
    if (oldUsername !== newUsername) {
        if (await db.userExists(newUsername)) {
            return { error: '新用户名已存在' };
        }

        // Update password if provided
        if (newPassword) {
            user.password = await hashPassword(newPassword);
            user.tokenVersion = (user.tokenVersion || 0) + 1;
        }

        // Update nickname
        user.nickname = nickname || undefined;

        // 1. Create new user record
        await db.setUser(newUsername, {
            ...user,
            username: newUsername // Ensure username is updated in the object
        });

        // 2. Migrate subscriptions
        const subs = await db.getUserSubscriptions(oldUsername);
        for (const sub of subs) {
            const token = sub.token;
            const { token: _, ...subData } = sub;
            subData.username = newUsername;
            await db.updateSubscription(token, subData); // TODO: Verify if username/user_id update is needed for rename support
        }

        // 3. Delete old user
        await db.deleteUser(oldUsername);

        // If password changed or username changed (which means new identity), invalidating old sessions is good.
        // Old sessions were for `oldUsername` (and old `user_id`).
        // `deleteUser` deletes the user.
        // `sessions` table might need manual cleanup if no cascade.
        await Promise.all([
            db.deleteAllUserSessions(user.id),
            db.deleteAllUserRefreshTokens(user.id)
        ]);

    } else {
        // Just password/nickname update
        if (newPassword) {
            user.password = await hashPassword(newPassword);
            user.tokenVersion = (user.tokenVersion || 0) + 1;
        }
        user.nickname = nickname || undefined;
        await db.setUser(oldUsername, user);

        // Invalidate sessions if password changed
        if (newPassword) {
            await Promise.all([
                db.deleteAllUserSessions(user.id),
                db.deleteAllUserRefreshTokens(user.id)
            ]);
        }
    }

    revalidatePath('/admin');
    revalidatePath('/dashboard');
    return { success: true };
}

export async function deleteUser(username: string) {
    // Delete all subscriptions for this user first
    const userSubs = await db.getUserSubscriptions(username);
    for (const sub of userSubs) {
        await db.deleteSubscription(sub.token, username);
    }

    // Delete avatar if exists
    const user = await db.getUser(username);
    if (user) {
        // Delete avatar if exists
        if (user.avatar) {
            try {
                const { StorageFactory } = await import('@/lib/storage');
                const storage = await StorageFactory.createFromGlobalConfig();
                await storage.delete(user.avatar);
            } catch (error) {
                console.warn('Failed to delete user avatar:', error);
            }
        }

        // Delete all sessions and refresh tokens
        await Promise.all([
            db.deleteAllUserSessions(user.id),
            db.deleteAllUserRefreshTokens(user.id)
        ]);
    }

    // Then delete the user
    await db.deleteUser(username);
    revalidatePath('/admin/users');
}

export async function adminUploadAvatar(formData: FormData) {
    const username = formData.get('username') as string;
    const file = formData.get('avatar') as File;

    if (!username || !file) {
        return { error: 'Missing required fields' };
    }

    // Check file size (10MB)
    if (file.size > 10 * 1024 * 1024) {
        return { error: '文件大小不能超过 10MB' };
    }

    // Check file type
    if (!file.type.startsWith('image/')) {
        return { error: '只支持图片文件' };
    }

    try {
        // Convert file to buffer
        const arrayBuffer = await file.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);

        // Validate and process image
        const { ImageProcessor } = await import('@/lib/image-processor');
        const isValid = await ImageProcessor.validateImage(buffer);
        if (!isValid) {
            return { error: '无效的图片文件' };
        }

        // Process image (resize to 500x500, convert to WebP)
        const processedBuffer = await ImageProcessor.processAvatar(buffer, 500);

        // Get user
        const user = await db.getUser(username);
        if (!user) {
            return { error: '用户不存在' };
        }

        // Delete old avatar if exists
        if (user.avatar) {
            try {
                const { StorageFactory } = await import('@/lib/storage');
                const storage = await StorageFactory.createFromGlobalConfig();
                await storage.delete(user.avatar);
            } catch (error) {
                console.warn('Failed to delete old avatar:', error);
            }
        }

        // Upload new avatar
        const { StorageFactory } = await import('@/lib/storage');
        const storage = await StorageFactory.createFromGlobalConfig();
        const avatarUrl = await storage.upload(
            processedBuffer,
            `${user.id}-${Date.now()}`,
            'image/webp'
        );

        // Update user avatar in database
        await db.setUser(username, {
            ...user,
            avatar: avatarUrl,
        });

        revalidatePath('/admin/users');
        return { success: true, avatarUrl };
    } catch (error) {
        console.error('Admin avatar upload error:', error);
        return { error: '上传失败，请稍后重试' };
    }
}

export async function adminDeleteAvatar(username: string) {
    // Get user
    const user = await db.getUser(username);
    if (!user) {
        return { error: '用户不存在' };
    }

    if (!user.avatar) {
        return { error: '该用户未设置头像' };
    }

    try {
        // Delete avatar from storage
        const { StorageFactory } = await import('@/lib/storage');
        const storage = await StorageFactory.createFromGlobalConfig();
        await storage.delete(user.avatar);
    } catch (error) {
        console.warn('Failed to delete avatar from storage:', error);
    }

    // Update user avatar in database
    await db.setUser(username, {
        ...user,
        avatar: undefined,
    });

    revalidatePath('/admin/users');
    return { success: true };
}

export async function resetUser2FA(username: string) {
    const user = await db.getUser(username);
    if (!user) {
        return { error: '用户不存在' };
    }

    await db.setUser(username, {
        ...user,
        totpEnabled: false,
        totpSecret: undefined,
    });

    revalidatePath('/admin/users');
    return { success: true };
}
